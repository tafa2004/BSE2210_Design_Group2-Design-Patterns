# Software Design Assignment: Building a Simple Monolith Event Management Application with Authentication, User Roles, and Realtime Features

## Overview
In this assignment, you will build a simplified monolith web application to demonstrate key software design principles, including authentication, user roles, realtime updates, and integration with modern tools. This directly builds on your previous assignment where you implemented various software designs for an "event" app (e.g., patterns, architectures, or prototypes for event management systems)—now, apply those concepts by constructing a full-stack monolith version of that event app. Adapt and implement the event-related systems you built previously into this monolith structure. The app will be a basic **collaborative event management system** where users can create, update, and delete events, RSVP to events, and receive realtime updates (e.g., when someone RSVPs or an event is updated, others see it live without refreshing). Incorporate user roles (e.g., admin for approving events, organizer for creating/managing, attendee for RSVPing) to add access control, drawing from any role-based designs in your prior work. As you build this, actively look into and apply design principles (e.g., SOLID principles, separation of concerns, modularity, scalability considerations) to ensure your code is maintainable and follows best practices—reflect on these in your README or video for extra insight.

The goal is to create a secure, realtime application using specified technologies, deploy it, and demonstrate its functionality. This assignment emphasizes clean architecture, documentation, and testing. **Encouragement:** Leverage the power of AI tools (like Grok, ChatGPT, or Copilot) extensively to accelerate your development—use them to generate boilerplate code, debug errors, explain concepts, or even suggest integrations based on your prior event app designs. This is a great opportunity to prototype quickly and iterate fast! Always cross-reference the official documentation for each tool (links provided below) to ensure accuracy and best practices—docs are your best friend for reliable implementation.

**Important Notes:**
- Keep the app simple: Focus on core features rather than advanced UI/UX. Build directly on your previous event app implementations for efficiency.
- The backend will handle API routes, auth, database interactions, and websockets.
- Test your API endpoints thoroughly using Insomnia (or similar tools like Postman) to ensure they work as expected.
- All code should be in a single GitHub repository (monolith structure: backend and optional frontend in one repo).
- If you encounter issues with integrations, refer to official documentation for each tool (see Resources section).

## Suggested Folder Structure
For simplicity and to promote separation of concerns (a key design principle), organize your monolith repo like this. This structure keeps everything modular within the single app—use it as a starting point and adapt as needed:

```
event-monolith-app/
├── src/
│   ├── controllers/       # Handle business logic for routes (e.g., eventController.ts, authController.ts)
│   │   ├── auth.controller.ts
│   │   ├── event.controller.ts
│   │   └── rsvp.controller.ts
│   ├── middleware/        # Auth, role checks, validation (e.g., authMiddleware.ts)
│   │   └── auth.middleware.ts
│   ├── routes/            # Define Elysia routes (e.g., auth.routes.ts, event.routes.ts)
│   │   ├── auth.routes.ts
│   │   └── event.routes.ts
│   ├── services/          # External integrations (e.g., emailService.ts for Ethereal, wsService.ts for websockets)
│   │   ├── email.service.ts
│   │   └── websocket.service.ts
│   ├── utils/             # Helpers (e.g., jwtUtils.ts, errorHandler.ts)
│   │   └── jwt.utils.ts
│   ├── prisma/            # Prisma schema and client
│   │   └── schema.prisma
│   └── index.ts           # Main server entry: Setup Elysia, plugins, routes, WS
├── prisma/                # Migrations (generated by Prisma)
│   └── migrations/
├── public/                # Optional static files (for bonus frontend assets)
├── .env                   # Environment variables (e.g., DATABASE_URL, JWT_SECRET)
├── package.json
├── tsconfig.json          # If using TypeScript (recommended for better design/time safety)
├── README.md              # Instructions, design principle reflections
└── render.yaml            # Optional Render config file
```

- **Why this structure?** It applies separation of concerns: Controllers for logic, middleware for cross-cutting (auth), routes for endpoints. This makes the code scalable and easier to test/refactor (SOLID: Single Responsibility, Open-Closed).
- If adding bonus frontend: Add a `frontend/` folder with `index.html`, `app.js`, etc., or integrate Vite/React in a subdir.
- **AI Tip:** Use AI to generate folder/files based on this—e.g., "Create Elysia routes in TypeScript following this structure."

## Prisma Models (Database Schema)
For simplicity, paste this directly into `src/prisma/schema.prisma`. It defines the models with relations, enums, and defaults. Run `npx prisma generate` after setup to create the client. This builds on standard event app patterns—adapt from your previous designs.

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")  // Neon connection string
}

enum UserRole {
  ADMIN
  ORGANIZER
  ATTENDEE
}

enum RSVPStatus {
  GOING
  MAYBE
  NOT_GOING
}

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  password  String    // Hashed
  role      UserRole  @default(ATTENDEE)
  createdAt DateTime  @default(now())

  organizedEvents Event[] @relation("EventOrganizer")
  rsvps           RSVP[]
}

model Event {
  id          String    @id @default(uuid())
  title       String
  description String
  date        DateTime
  location    String
  organizerId String
  approved    Boolean   @default(false)
  createdAt   DateTime  @default(now())

  organizer   User      @relation("EventOrganizer", fields: [organizerId], references: [id])
  rsvps       RSVP[]
}

model RSVP {
  id        String      @id @default(uuid())
  userId    String
  eventId   String
  status    RSVPStatus
  createdAt DateTime    @default(now())

  user      User        @relation(fields: [userId], references: [id])
  event     Event       @relation(fields: [eventId], references: [id])

  @@unique([userId, eventId])  // Prevent duplicate RSVPs
}
```

- **Migrations:** After writing schema, run `npx prisma migrate dev --name init` (Prisma docs).
- **Design Principle Application:** This uses relational integrity (foreign keys) for data consistency (DRY principle) and enums for type safety.

## Objectives
- Implement user authentication with email mocking.
- Add user roles for access control (e.g., admin, organizer, attendee).
- Add realtime functionality using websockets for live event and RSVP updates.
- Use Prisma for database ORM and Neon for hosting the PostgreSQL database.
- Generate API documentation with Swagger via Elysia.js.
- Deploy the app to Render and ensure it's live.
- (Bonus) Add a simple frontend for extra points.
- Create a short demo video.
- Apply design principles throughout the building process.

## Required Technologies
- **Backend Framework:** Elysia.js (for building the API, handling routes, and generating Swagger docs automatically).
- **Database ORM:** Prisma (connect to Neon's PostgreSQL database).
- **Database:** Neon (free tier PostgreSQL service; provides a connection string for Prisma).
- **Email Mocking:** Ethereal API (for simulating email sending, e.g., during user signup for verification emails).
- **Deployment:** Render (deploy the backend; if adding frontend, host it together or separately on Render).
- **Testing Tool:** Insomnia (use it to test API endpoints like login, event creation, etc.).
- **Other:** Node.js (latest LTS), Git for version control. For authentication, implement manually using JWT (e.g., with `jsonwebtoken` library). For realtime, use Elysia's built-in websocket support.

**Setup Tips:**
- Start by creating a free Neon project: It gives you a PostgreSQL connection string for Prisma.
- In Prisma, use the Neon PostgreSQL URL in your `schema.prisma` file.
- Elysia.js handles auth middleware and websockets natively.
- For Ethereal: Sign up for a free account and use their API to send mock emails (no real delivery needed). Integrate with Nodemailer.
- **AI Tip:** Ask AI to generate starter code for Elysia.js server setup, Prisma schema, or JWT auth—save hours on boilerplate, and adapt from your previous event app code!

## Resources and Documentation
Make heavy use of these official docs—search them for specifics, and use AI to summarize or explain sections if needed, especially when mapping to your prior event app designs:
- Elysia.js: https://elysiajs.com/ (Quick start, Swagger plugin: https://elysiajs.com/plugins/swagger;
- Websockets: https://elysiajs.com/patterns/websocket)
- Prisma: https://www.prisma.io/docs (Schema setup, migrations, Neon integration examples)
- Neon: https://neon.tech/docs (Getting started, connection strings)
- Ethereal API (Nodemailer Ethereal): https://ethereal.email/ (Usage with Node.js: search for "nodemailer ethereal" tutorials)
- JWT for Auth: https://www.npmjs.com/package/jsonwebtoken (Basic usage)
- Render Deployment: https://render.com/docs (Node.js services, env vars)
- Insomnia: https://docs.insomnia.rest/ (API testing, websockets)

## Core Features and Requirements
Your app must include the following features. Implement them in a monolith structure (single server handling everything). Use AI to quickly stub out routes or handlers based on your previous event app designs, then refine with docs. Remember to incorporate design principles like SOLID to structure your code effectively (e.g., single-responsibility controllers).

### 1. Database Schema (Using Prisma and Neon)
- Use the provided schema above in `src/prisma/schema.prisma`.
- Neon hosts the DB; handle realtime via websockets in Elysia.
- **Quick Tip:** Use AI to generate queries/services based on these models.

### 2. Authentication and User Roles
- Implement user registration and login manually:
  - Use JWT for tokens (sign/verify with `jsonwebtoken`).
  - Hash passwords with bcrypt.
  - During signup: Assign default role 'ATTENDEE'; send a mock verification email using Ethereal API (e.g., "Welcome to Event App" with a fake link)—integrate via Nodemailer in Elysia.
- Login: Return a JWT token for authenticated requests.
- Protect API routes: Use middleware in Elysia.js to check JWT and user role (e.g., only 'ORGANIZER' can create events, 'ADMIN' can approve).
- Test in Insomnia: 
  - POST /signup: Body {email, password, role?} → Expect 201 with success message and mock email sent.
  - POST /login: Body {email, password} → Expect 200 with JWT token.

### 3. API Endpoints (Using Elysia.js)
- Build routes in Elysia.js, adapting from your prior event app logic:
  - GET /events: Fetch all approved events (authenticated; return JSON list).
  - POST /events: Create a new event (authenticated, organizer role; body {title, description, date, location}).
  - PUT /events/:id: Update an event (authenticated, organizer or admin; body {title, description, date, location}).
  - DELETE /events/:id: Delete an event (authenticated, organizer or admin).
  - POST /events/:id/rsvp: RSVP to an event (authenticated, attendee role; body {status}).
  - PUT /events/:id/approve: Approve an event (authenticated, admin role).
- Integrate Swagger: Add `@elysiajs/swagger` plugin to auto-generate docs at /swagger (follow Elysia Swagger docs—AI can help install and configure).
- Test in Insomnia: Import your Swagger JSON into Insomnia for easy testing. Ensure all endpoints return proper status codes (e.g., 401 for unauthorized, 403 for insufficient role).

### 4. Realtime Functionality (Websockets)
- Use Elysia's built-in websockets to broadcast event and RSVP changes.
- When an event is created/updated/deleted/approved or RSVP added/updated, trigger a websocket broadcast.
- Set up a websocket endpoint (e.g., /ws) for clients to connect and receive updates (Elysia WS docs; subscribe to channels like 'events' or 'rsvps').
- Example: On event creation, insert via Prisma and broadcast to connected clients.
- Test: In Insomnia (which supports websockets), connect to ws://your-render-url/ws and simulate sending/receiving updates.
- **AI Boost:** Generate websocket handler code with AI using Elysia examples from docs, drawing parallels to any realtime designs from your previous event app.

### 5. Error Handling and Validation
- Validate inputs (e.g., email format, required fields, valid dates) using Elysia.js decorators.
- Handle errors gracefully (e.g., 400 for bad input, 500 for server errors, 403 for role mismatches).

## Deployment
- Deploy the entire app to Render (free tier works for this).
- Create a new Web Service on Render, connect your GitHub repo, and set environment variables (e.g., DATABASE_URL for Neon, JWT_SECRET, ETHEREAL_API_KEY)—Render docs for env setup.
- Ensure the app is live and accessible (e.g., https://your-app.onrender.com).
- Swagger docs should be available at /swagger on the deployed URL.
- Realtime websockets must work on the live site.

## Bonus: Simple Frontend (Extra Points)
- Build a basic frontend using HTML/CSS/JS (or a framework like React if comfortable, but keep it simple).
- Features: Login form, event list with create/update/delete/RSVP buttons (role-based), realtime updates (use WebSocket API in JS).
- Host on Render (static site or integrated with backend).
- This is optional but worth extra credit for demonstrating full-stack integration. **AI Tip:** Use AI to generate React components quickly, building on UI designs from your previous event app work.

## Testing Guidelines
- Use Insomnia to test all API endpoints:
  - Auth: Signup, login, protected routes with roles.
  - Events: CRUD operations, approve, RSVP.
  - Websockets: Connect and verify live updates.
- Ensure the app handles edge cases (e.g., invalid token, insufficient role, duplicate email).
- Self-test locally before deploying (reference tool docs for local setup).

## Submission Requirements
- **GitHub Repo:** Push your code to a public GitHub repo (include README with setup instructions, how to run locally, and Swagger usage). Note connections to your previous event app assignment's designs in the README, including how you applied design principles.
- **Demo Video:** Record a 3-minute video (use Loom, YouTube, or similar) demoing:
  - Signup/login with mock email (show Ethereal inbox if possible).
  - Creating/updating/deleting/approving events with role checks and realtime updates (open two browser tabs to show live sync).
  - RSVPing to an event with realtime updates.
  - API testing in Insomnia (quick demo of one endpoint).
  - Swagger docs.
  - The live app on Render.
- **Submission Link:** Submit via this Google Form: https://forms.gle/L1GwpEYVvPH51p918
  - Include: GitHub repo URL, Deployed Render URL, Demo video URL.

## Evaluation Criteria
- Functionality: All core features work (auth, roles, realtime, API).
- Code Quality: Clean, organized monolith structure (following suggested folders); proper use of technologies, with evidence of applying previous event app implementations and design principles.
- Documentation: Swagger works; README is clear.
- Deployment: App is live and stable on Render.
- Testing: Evidence of Insomnia testing (mention in README or video).
- Bonus: Frontend integration.
- Timeliness: Meets deadline.
- Effective Use of Tools: Evidence of AI-assisted development (e.g., mention in README) and doc references for bonus consideration.

## Deadline
This assignment is due by **Friday, October 24, 2025, at 11:59 PM**. Late submissions will incur penalties.

If you have questions, ask in class or via email. Good luck! Embrace AI to build faster, refer to docs often, and draw from your previous event app assignment—this combo will make you unstoppable in software design.
